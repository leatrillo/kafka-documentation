<div style="background-color: rgba(0, 0, 0, 0.8); border-radius: 60px">

![Banner](/.attachments/banner-d8ceca44-805f-4dd2-b8dc-8d1d3905810d.png =385x120)

</div>  
  
**Coelsa.Artifact.Secrets**

[![NuGet Version](https://img.shields.io/badge/version-8.0.0--RC-blue)](https://dev.azure.com/coelsa/Extensions/_artifacts/feed/Coelsa-F01/NuGet/Coelsa.Artifact.Secrets/overview/8.0.0-RC)
[![.NET 8](https://img.shields.io/badge/.NET-8.0-purple)](https://dotnet.microsoft.com/download/dotnet/8.0)

  

Artefacto de Cross-Cutting Concern (CCC) para la gestiÃ³n centralizada y segura de secretos desde Azure Key Vault en aplicaciones .NET 8. Este paquete simplifica la integraciÃ³n con Azure Key Vault mediante inyecciÃ³n de dependencias, proporcionando acceso tipado y seguro a secretos empresariales.
  

---

ğŸ“‹ Tabla de Contenidos

[[_TOC_]]

---

  

## ğŸš€ CaracterÃ­sticas

  

- âœ… **InyecciÃ³n de Dependencias**: IntegraciÃ³n nativa con el contenedor de DI de .NET

- âœ… **Tipado Fuerte**: Acceso a secretos mediante clases fuertemente tipadas con IntelliSense

- âœ… **Tres Modos de RecuperaciÃ³n**: Flexibilidad para recuperar todos los secretos, especÃ­ficos o con mapeo personalizado

- âœ… **Reintentos Configurables**: PolÃ­tica de reintentos personalizable para resiliencia

- âœ… **Manejo de Errores**: Callbacks opcionales para gestiÃ³n personalizada de excepciones

- âœ… **ValidaciÃ³n AutomÃ¡tica**: ValidaciÃ³n de opciones en el inicio de la aplicaciÃ³n (`ValidateOnStart`)

- âœ… **Mapeo Personalizado**: Soporte para `JsonPropertyName` en propiedades

- âœ… **Service Principal Authentication**: AutenticaciÃ³n segura mediante Azure AD Service Principal

- âœ… **ConfiguraciÃ³n automatica del Cliente**: No necesitas crear manualmente `SecretClient` o gestionar credenciales

  

---

  

## ğŸ“¦ Requisitos

  

### Software Requerido

  

- [.NET 8 SDK](https://dotnet.microsoft.com/download/dotnet/8.0) o superior

- [Visual Studio 2022](https://visualstudio.microsoft.com/vs/community/) (opcional, Community Edition o superior)

  

### Recursos de Azure

  

- **Azure Subscription** activa

- **Azure Key Vault** creado y configurado

- **Service Principal** registrado en Azure AD con los siguientes permisos en Key Vault:

Â  - `Get` (obligatorio)

Â  - `List` (obligatorio)

  

## ğŸ“¥ InstalaciÃ³n

  

### Paso 1: Configurar el Origen de NuGet

  

El paquete estÃ¡ alojado en un feed privado de Azure Artifacts. Agrega el origen ejecutando:

  

```powershell

dotnet nuget add source "https://pkgs.dev.azure.com/coelsa/_packaging/Coelsa-F01/nuget/v3/index.json" `

Â  --name "Coelsa-F01" `

Â  --username <tu-usuario-azure-devops> `

Â  --password <tu-personal-access-token> `

Â  --store-password-in-clear-text

```

  

**En Visual Studio:**

  

1. Herramientas â†’ Opciones â†’ Administrador de paquetes NuGet â†’ OrÃ­genes de paquetes

2. Haz clic en el botÃ³n **+** para agregar un nuevo origen

3. Nombre: `Coelsa-F01`

4. Origen: `https://pkgs.dev.azure.com/coelsa/_packaging/Coelsa-F01/nuget/v3/index.json`

  

### Paso 2: Instalar el Paquete

  

**Usando .NET CLI:**

  

```powershell

dotnet add package Coelsa.Artifact.Secrets --prerelease

```

  

**Usando Package Manager Console (Visual Studio):**

  

```powershell

Install-Package Coelsa.Artifact.Secrets -Prerelease

```

  

**Usando el Administrador de Paquetes NuGet de Visual Studio:**

  

1. Clic derecho en el proyecto â†’ Administrar paquetes NuGet

2. Selecciona el origen **Coelsa-F01**

3. Marca la casilla **Incluir versiÃ³n preliminar**

4. Busca `Coelsa.Artifact.Secrets` e instala

  

---

  

## ğŸš¦ Inicio RÃ¡pido

  

### 1. Configurar appsettings.json

  

```json

{

Â  "KeyVault": {

Â  Â  "Url": "https://tu-keyvault.vault.azure.net/",

Â  Â  "TenantId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",

Â  Â  "AppClientId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",

Â  Â  "SecretValue": "tu-client-secret-del-service-principal"

Â  }

}

```

  

### 2. Crear Clase de Opciones

  

La clase debe contener como propiedades los mismos nombres de las key que se encuentran en el repositorio de KeyVault.

  

```csharp

namespace MiAplicacion.Configuration;

  

public class SecretsSettings

{

Â  Â  public string DatabaseConnectionString { get; init; } = string.Empty;

Â  Â  public string ApiKey { get; init; } = string.Empty;

}

```

  

### 3. Registrar en Program.cs

  

```csharp

using Coelsa.Artifact.Secrets;

  

builder.Services.AddCoelsaSecrets<SecretsSettings>(builder.Configuration);

  

```

  

### 4. Usar en tus Servicios

  

```csharp

using Microsoft.Extensions.Options;

  

[ApiController]

[Route("api/[controller]")]

public class ProductsController : ControllerBase

{

Â  Â  private readonly SecretsSettings _secrets;

Â  Â  public ProductsController(IOptions<SecretsSettings> secrets)

Â  Â  {

Â  Â  Â  Â  _secrets = secrets.Value;

Â  Â  }

Â  Â  [HttpGet]

Â  Â  public IActionResult Get()

Â  Â  {

Â  Â  Â  Â  var connectionString = _secrets.DatabaseConnectionString;

Â  Â  Â  Â  // Usar el secreto...

Â  Â  Â  Â  return Ok();

Â  Â  }

}

```

  

---

  

## âš™ï¸ ConfiguraciÃ³n

  

### ParÃ¡metros de ConfiguraciÃ³n

  

| ParÃ¡metro | Tipo | Requerido | Default | DescripciÃ³n |
|-----------|------|-----------|---------|-------------|
| `Url` | `string` | âœ… SÃ­ | - | URL completa del Azure Key Vault (ej: `https://mi-vault.vault.azure.net/`) |
| `TenantId` | `string` | âœ… SÃ­ | - | ID del Tenant de Azure AD donde estÃ¡ registrado el Service Principal |
| `AppClientId` | `string` | âœ… SÃ­ | - | Application (Client) ID del Service Principal |
| `SecretValue` | `string` | âœ… SÃ­ | - | Client Secret del Service Principal |
| `DelayInMs` | `int?` | âŒ No | `6000` | Delay inicial entre reintentos en milisegundos |
| `MaxDelayInMs` | `int?` | âŒ No | `12000` | Delay mÃ¡ximo entre reintentos en milisegundos |
| `Retries` | `int?` | âŒ No | `5` | Cantidad mÃ¡xima de reintentos en caso de fallo |
| `SpecificSecrets` | `string?` | âŒ No | `null` | Lista de secretos especÃ­ficos separados por coma |
| `SecretOptions` | `object?` | âŒ No | `null` | Diccionario de mapeo propiedad â†’ nombre de secreto |


### ConfiguraciÃ³n BÃ¡sica
âš ï¸ Los secretos para la conexiÃ³n al repositorio de KeyVault no deben ser versionados. En desarrollo local con visual studio se deben agregar en secretos de usuarios.

```json

{

Â  "KeyVault": {

Â  Â  "Url": "{secret}",

Â  Â  "TenantId": "{secret}",

Â  Â  "AppClientId": "{secret}",

Â  Â  "SecretValue": "{secret}"

Â  }

}

```

  

### ConfiguraciÃ³n Avanzada con Reintentos

  

```json

{

Â  "KeyVault": {

Â  Â  "Url": "{secret}",

Â  Â  "TenantId": "{secret}",

Â  Â  "AppClientId": "{secret}",

Â  Â  "SecretValue": "{secret}",

Â  Â  "DelayInMs": 3000,

Â  Â  "MaxDelayInMs": 8000,

Â  Â  "Retries": 3

Â  }

}

```
---

## ğŸ”„ Modos de OperaciÃ³n

El paquete soporta tres modos de recuperaciÃ³n de secretos. El modo se determina automÃ¡ticamente segÃºn la configuraciÃ³n proporcionada.

 
### Modo 1: RecuperaciÃ³n Completa (Predeterminado)
 

Recupera **todos los secretos** del Key Vault cuyo nombre coincida con el patrÃ³n esperado.

**ConfiguraciÃ³n:**

```json

{

Â  "KeyVault": {

Â  Â  "Url": "{secret}",

Â  Â  "TenantId": "{secret}",

Â  Â  "AppClientId": "{secret}",

Â  Â  "SecretValue": "{secret}"

Â  }

}

```

**ConvenciÃ³n de nombres en Azure Key Vault:**

Los secretos deben seguir el patrÃ³n: `{NombrePropiedad}`

**Ejemplo:**  

```csharp

public class SecretsSettings

{

Â  Â  public string DatabaseConnectionString { get; init; } = string.Empty;

Â  Â  public string ApiKey { get; init; } = string.Empty;

}

```

**Secretos en Key Vault:**

- `DatabaseConnectionString`

- `ApiKey`


**Registro:**

```csharp

builder.Services.AddCoelsaSecrets<SecretsSettings>(builder.Configuration);

```

### Modo 2: Secretos EspecÃ­ficos  

Recupera **Ãºnicamente los secretos listados** en `SpecificSecrets`.

**ConfiguraciÃ³n:**

```json

{

Â  "KeyVault": {

Â  Â  "Url": "{secret}",

Â  Â  "TenantId": "{secret}",

Â  Â  "AppClientId": "{secret}",

Â  Â  "SecretValue": "{secret}",

Â  Â  "SpecificSecrets": "ConnectionString,ApiKey,Certificate"

Â  }

}

```


**Clase de Opciones:**

```csharp

public class SecretsSettings

{

Â  Â  public string ConnectionString { get; init; } = string.Empty;

Â  Â  public string ApiKey { get; init; } = string.Empty;

Â  Â  public string Certificate { get; init; } = string.Empty;

}

```

  

**Ventajas:**

- Control preciso sobre quÃ© secretos se cargan

- Ãštil cuando hay muchos secretos en el Key Vault

- Mejora el rendimiento al reducir las llamadas


### Modo 3: Mapeo Personalizado (SecretOptions)

Permite **mapear propiedades a nombres de secretos especÃ­ficos** mediante un diccionario.

**ConfiguraciÃ³n:**

```json

{

Â  "KeyVault": {
Â  Â  "Url": "{secret}",
Â  Â  "TenantId": "{secret}",
Â  Â  "AppClientId": "{secret}",
Â  Â  "SecretValue": "{secret}",
Â  Â  "SecretOptions": {
Â  Â  Â  "ConnectionString": "SqlServer-ConnectionString-Production",
Â  Â  Â  "Certificate": "OpenTelemetry-Certificate-PROD",
Â  Â  Â  "ApiKey": "ExternalApi-Key-v2"
Â  Â  }
Â  }
}

```

  
**Clase de Opciones:**

```csharp

public class SecretsSettings

{

Â  Â  public string ConnectionString { get; init; } = string.Empty;

Â  Â  public string Certificate { get; init; } = string.Empty;

Â  Â  public string ApiKey { get; init; } = string.Empty;

}

```

**Ventajas:**

- Nombres de secretos independientes de la estructura de clases

- Facilita la migraciÃ³n de secretos sin cambiar cÃ³digo

- Soporta convenciones de nomenclatura complejas

  
### Uso con JsonPropertyName

Para propiedades con nombres diferentes al secreto:

```csharp

using System.Text.Json.Serialization;

  

public class SecretsSettings

{

Â  Â  [JsonPropertyName("Database-ConnectionString")]

Â  Â  public string ConnectionString { get; init; } = string.Empty;

}

```

---

  

## ğŸ’¼ Uso en la AplicaciÃ³n

### InyecciÃ³n en Controladores

  

```csharp

using Microsoft.AspNetCore.Mvc;

using Microsoft.Extensions.Options;

  

[ApiController]

[Route("api/[controller]")]

public class OrdersController : ControllerBase

{

Â  Â  private readonly SecretsSettings _secrets;

Â  Â  private readonly ILogger<OrdersController> _logger;

Â  Â  public OrdersController(

Â  Â  Â  Â  IOptions<SecretsSettings> secrets,

Â  Â  Â  Â  ILogger<OrdersController> logger)

Â  Â  {

Â  Â  Â  Â  _secrets = secrets.Value;

Â  Â  Â  Â  _logger = logger;

Â  Â  }

Â  Â  [HttpPost]

Â  Â  public async Task<IActionResult> CreateOrder([FromBody] Order order)

Â  Â  {

Â  Â  Â  Â  _logger.LogInformation("Conectando a base de datos...");

Â  Â  Â  Â  var connectionString = _secrets.DatabaseConnectionString;

Â  Â  Â  Â  // Usar el secreto...

Â  Â  Â  Â  return CreatedAtAction(nameof(GetOrder), new { id = order.Id }, order);

Â  Â  }

}

```

  

### InyecciÃ³n en Servicios

  

```csharp

public class EmailService : IEmailService

{

Â  Â  private readonly SecretsSettings _secrets;

Â  Â  public EmailService(IOptions<SecretsSettings> secrets)

Â  Â  {

Â  Â  Â  Â  _secrets = secrets.Value;

Â  Â  }

Â  Â  public async Task SendEmailAsync(string to, string subject, string body)

Â  Â  {

Â  Â  Â  Â  var apiKey = _secrets.SendGridApiKey;

Â  Â  Â  Â  // Usar SendGrid con el API Key...

Â  Â  }

}

  

// Registro

builder.Services.AddScoped<IEmailService, EmailService>();

builder.Services.AddCoelsaSecrets<SecretsSettings>(builder.Configuration);

```

  

### Acceso Directo en Program.cs

  

```csharp

var builder = WebApplication.CreateBuilder(args);

  

builder.Services.AddCoelsaSecrets<SecretsSettings>(builder.Configuration);

  

var app = builder.Build();

  

var secrets = app.Services.GetRequiredService<IOptions<SecretsSettings>>().Value;

Console.WriteLine($"Conectando a: {secrets.DatabaseConnectionString}");

  

app.Run();

```

  

---

  

## âš ï¸ Manejo de Errores

  

### Ejemplo BÃ¡sico: Logging

  

```csharp

builder.Services.AddCoelsaSecrets<SecretsSettings>(

Â  Â  builder.Configuration,

Â  Â  ex =>

Â  Â  {

Â  Â  Â  Â  var logger = builder.Services.BuildServiceProvider()

Â  Â  Â  Â  Â  Â  .GetRequiredService<ILogger<Program>>();

Â  Â  Â  Â  logger.LogError(ex, "Error al recuperar secretos de Azure Key Vault");

Â  Â  });

```

  

### Ejemplo: Lanzar ExcepciÃ³n Personalizada

  

```csharp

builder.Services.AddCoelsaSecrets<SecretsSettings>(

Â  Â  builder.Configuration,

Â  Â  ex =>

Â  Â  {

Â  Â  Â  Â  throw new InvalidOperationException(

Â  Â  Â  Â  Â  Â  $"No se pudieron cargar los secretos: {ex.Message}. " +

Â  Â  Â  Â  Â  Â  $"Verifique la conectividad con Azure Key Vault y los permisos del Service Principal.",

Â  Â  Â  Â  Â  Â  ex);

Â  Â  });

```

  

### Ejemplo: Manejo por Tipo de ExcepciÃ³n

```csharp

using Azure;

using Azure.Identity;

  

builder.Services.AddCoelsaSecrets<SecretsSettings>(

Â  Â  builder.Configuration,

Â  Â  ex =>

Â  Â  {

Â  Â  Â  Â  var logger = builder.Services.BuildServiceProvider()

Â  Â  Â  Â  Â  Â  .GetRequiredService<ILogger<Program>>();

Â  Â  Â  Â  switch (ex)

Â  Â  Â  Â  {

Â  Â  Â  Â  Â  Â  case AuthenticationFailedException authEx:

Â  Â  Â  Â  Â  Â  Â  Â  logger.LogError(authEx,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "Error de autenticaciÃ³n. Verifique TenantId, AppClientId y SecretValue");

Â  Â  Â  Â  Â  Â  Â  Â  throw new UnauthorizedAccessException(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "Credenciales invÃ¡lidas para Key Vault", authEx);

Â  Â  Â  Â  Â  Â  case RequestFailedException reqEx when reqEx.Status == 404:

Â  Â  Â  Â  Â  Â  Â  Â  logger.LogWarning(reqEx,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "Secreto no encontrado. Verifique los nombres en Key Vault");

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  case RequestFailedException reqEx when reqEx.Status == 403:

Â  Â  Â  Â  Â  Â  Â  Â  logger.LogError(reqEx,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "Acceso denegado. El Service Principal no tiene permisos");

Â  Â  Â  Â  Â  Â  Â  Â  throw new UnauthorizedAccessException(

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  "Sin permisos para acceder a Key Vault", reqEx);

Â  Â  Â  Â  Â  Â  default:

Â  Â  Â  Â  Â  Â  Â  Â  logger.LogError(ex, "Error inesperado al cargar secretos");

Â  Â  Â  Â  Â  Â  Â  Â  if (builder.Environment.IsProduction())

Â  Â  Â  Â  Â  Â  Â  Â  {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  throw;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  }

Â  Â  });

```

  

## ğŸ”§ ConfiguraciÃ³n Avanzada

  

### PolÃ­tica de Reintentos

  

El paquete usa una polÃ­tica de reintentos **Fixed** (intervalo fijo) configurable:

  

```json

{

Â  "KeyVault": {

Â  Â  "Url": "{secret}",

Â  Â  "TenantId": "{secret}",

Â  Â  "AppClientId": "{secret}",

Â  Â  "SecretValue": "{secret}",

Â  Â  "DelayInMs": 2000,

Â  Â  "MaxDelayInMs": 10000,

Â  Â  "Retries": 5

Â  }

}

```


**Comportamiento:**

- Primer intento: inmediato

- Reintento 1: despuÃ©s de `DelayInMs` (2s)

- Reintento 2: despuÃ©s de `DelayInMs` (2s)

- ...

- Reintento 5: despuÃ©s de `DelayInMs` (2s)

- Si todos fallan: se invoca el callback `onError`  

---

  

## âœ… ValidaciÃ³n de Secretos

  
### ValidaciÃ³n BÃ¡sica con DataAnnotations

  

```csharp

using System.ComponentModel.DataAnnotations;

  

public class SecretsSettings

{

Â  Â  [Required(ErrorMessage = "La cadena de conexiÃ³n es obligatoria")]

Â  Â  [MinLength(10, ErrorMessage = "La cadena de conexiÃ³n parece invÃ¡lida")]

Â  Â  public string DatabaseConnectionString { get; init; } = string.Empty;

Â  Â  [Required]

Â  Â  [RegularExpression(@"^[A-Za-z0-9-_]+$", ErrorMessage = "API Key con formato invÃ¡lido")]

Â  Â  public string ApiKey { get; init; } = string.Empty;

}

```

  

### ValidaciÃ³n Avanzada con FluentValidation

  

**Instalar paquete:**

  

```powershell

dotnet add package FluentValidation.DependencyInjectionExtensions

```

  

**Crear Validador:**

  

```csharp

using FluentValidation;

using Microsoft.Extensions.Options;

  

public class SecretsSettingsValidator : AbstractValidator<SecretsSettings>,

Â  Â  IValidateOptions<SecretsSettings>

{

Â  Â  public SecretsSettingsValidator()

Â  Â  {

Â  Â  Â  Â  RuleFor(x => x.DatabaseConnectionString)

Â  Â  Â  Â  Â  Â  .NotEmpty()

Â  Â  Â  Â  Â  Â  .WithMessage("La cadena de conexiÃ³n es requerida")

Â  Â  Â  Â  Â  Â  .Must(BeValidConnectionString)

Â  Â  Â  Â  Â  Â  .WithMessage("La cadena de conexiÃ³n tiene un formato invÃ¡lido");

Â  Â  Â  Â  RuleFor(x => x.ApiKey)

Â  Â  Â  Â  Â  Â  .NotEmpty()

Â  Â  Â  Â  Â  Â  .WithMessage("El API Key es requerido")

Â  Â  Â  Â  Â  Â  .Length(32, 128)

Â  Â  Â  Â  Â  Â  .WithMessage("El API Key debe tener entre 32 y 128 caracteres");

Â  Â  }

Â  Â  private bool BeValidConnectionString(string connectionString)

Â  Â  {

Â  Â  Â  Â  return connectionString.Contains("Server=") ||

Â  Â  Â  Â  Â  Â  Â  Â connectionString.Contains("Data Source=");

Â  Â  }

  

Â  Â  public ValidateOptionsResult Validate(string? name, SecretsSettings options)

Â  Â  {

Â  Â  Â  Â  var validationResult = this.Validate(options);

Â  Â  Â  Â  if (validationResult.IsValid)

Â  Â  Â  Â  Â  Â  return ValidateOptionsResult.Success;

Â  Â  Â  Â  var errors = string.Join("; ",

Â  Â  Â  Â  Â  Â  validationResult.Errors.Select(e => e.ErrorMessage));

Â  Â  Â  Â  return ValidateOptionsResult.Fail(errors);

Â  Â  }

}

```

  

**Registrar:**

  

```csharp

builder.Services.AddValidatorsFromAssemblyContaining<SecretsSettingsValidator>();

builder.Services.AddSingleton<IValidateOptions<SecretsSettings>, SecretsSettingsValidator>();

builder.Services.AddCoelsaSecrets<SecretsSettings>(builder.Configuration);

```

  

---

  

## ğŸ¯ Mejores PrÃ¡cticas

### 1. Nomenclatura de Secretos

MantÃ©n una convenciÃ³n consistente:

- âœ… {Propiedad}` â†’ `KafkaCertificate` se debe usar PascalCase 

- âŒ No utilizar caracteres especiales

- âŒ No agregar el ambiente al nombre

- âŒ No utilizar espacios en los nombres de secretos

   

### 2. Manejo de Errores  

- âœ… **Siempre** proporciona un callback `onError` en producciÃ³n

- âœ… Registra errores en un sistema de logging/monitoreo

- âœ… Diferencia el comportamiento por ambiente (dev vs prod)


### 3. ValidaciÃ³n

- âœ… Implementa validadores para secretos crÃ­ticos

- âœ… Usa `ValidateOnStart` (habilitado por defecto en el paquete)

- âœ… Valida formatos (ej: URLs, connection strings)

- âœ… Verifica que los secretos no estÃ©n vacÃ­os

  
### 4. Performance

- âœ… Usa `SpecificSecrets` cuando solo necesites algunos secretos

- âœ… Usa `SecretOptions` para mapeos complejos sin recuperar todo

- âœ… Configura reintentos apropiados segÃºn tu SLA

- âŒ Evita cargar secretos innecesarios


### 5. Inmutabilidad


```csharp

public class SecretsSettings

{

Â  Â  // âœ… Usa 'init' para propiedades inmutables

Â  Â  public string ApiKey { get; init; } = string.Empty;

Â  Â  // âŒ Evita 'set' que permite modificaciÃ³n posterior

Â  Â  // public string ApiKey { get; set; } = string.Empty;

}

```

---

  
## ğŸ” SoluciÃ³n de Problemas

  
### Error: "No se encuentran los parametros de configuracion"

**SÃ­ntoma:**

```

System.ArgumentException: No se encuentran los parametros de configuracion, verifique que esta la seccion 'KeyVault'

```

**Causas:**

- Falta la secciÃ³n `KeyVault` en la configuraciÃ³n

- El archivo `appsettings.json` no estÃ¡ siendo leÃ­do
  

**SoluciÃ³n:**

1. Verifica que exista la secciÃ³n `KeyVault` en `appsettings.json`

2. Confirma que el archivo estÃ© marcado como "Copy to Output Directory"

3. Verifica que no haya errores de sintaxis JSON

  
### Error de AutenticaciÃ³n

**SÃ­ntoma:**

```

Azure.Identity.AuthenticationFailedException: ClientSecretCredential authentication failed

```

  

**Causas:**

- `TenantId`, `AppClientId` o `SecretValue` incorrectos

- Service Principal deshabilitado o expirado
  

**SoluciÃ³n:**

1. Verifica las credenciales en Azure Portal

2. Confirma que el Service Principal estÃ© activo

3. Regenera el Client Secret si es necesario

4. Verifica que el `TenantId` corresponda al correcto

  

### Error 403: Acceso Denegado

**SÃ­ntoma:**

```

Azure.RequestFailedException: Status: 403 (Forbidden)

```
  

**Causas:**

- El Service Principal no tiene permisos en el Key Vault

- Las polÃ­ticas de acceso estÃ¡n mal configuradas

- No tienes conectada la vpn  

**SoluciÃ³n:**

- Conectarse a vpn.
- Validar permisos con el equipo de identity.

  
### Error 404: Secreto No Encontrado

**SÃ­ntoma:**

```

Azure.RequestFailedException: Status: 404 (Not Found)

```

**Causas:**

- El nombre del secreto en Key Vault no coincide con el esperado

- El secreto fue eliminado


**SoluciÃ³n:**

1. Verifica la nomenclatura segÃºn el modo usado

3. Ajusta `SpecificSecrets` o `SecretOptions` si es necesario

  

### Timeout al Recuperar Secretos

  
**SÃ­ntoma:**

- La aplicaciÃ³n tarda mucho en iniciar

- Errores de timeout

  
**Causas:**

- Reintentos insuficientes o delays muy largos

- Problemas de red o firewall

- Key Vault en regiÃ³n geogrÃ¡fica distante

  

**SoluciÃ³n:**

1. Ajusta los parÃ¡metros de reintentos:

```json

Â  Â {

Â  Â  Â "KeyVault": {

Â  Â  Â  Â "DelayInMs": 2000,

Â  Â  Â  Â "MaxDelayInMs": 5000,

Â  Â  Â  Â "Retries": 3

Â  Â  Â }

Â  Â }

```

2. Verifica reglas de firewall en Key Vault

3. Considera usar un Key Vault en la misma regiÃ³n


### Secretos No Se Mapean Correctamente
  

**SÃ­ntoma:**

- Propiedades tienen valores vacÃ­os o `null`

- No aparecen errores

  
**Causas:**

- Nomenclatura incorrecta en Azure Key Vault

- Uso incorrecto de `JsonPropertyName`

  
**SoluciÃ³n:**

  
**Modo Completo:**

```

Secreto en KV: DatabaseConnectionString

Propiedad: public string DatabaseConnectionString { get; init; }

```


**Modo SpecificSecrets:**

```json

{

Â  "SpecificSecrets": "DatabaseConnectionString"

}

```

```csharp

public string DatabaseConnectionString { get; init; }

```

  

**Modo SecretOptions:**

```json

{

Â  "SecretOptions": {

Â  Â  "DatabaseConnectionString": "SqlServer-PROD-ConnectionString"

Â  }

}

```

```csharp

public string DatabaseConnectionString { get; init; }

```

  
### Errores en Tiempo de CompilaciÃ³n

**SÃ­ntoma:**

```

The type or namespace name 'AddCoelsaSecrets' could not be found

```

  

**SoluciÃ³n:**

1. Verifica que el paquete estÃ© instalado:

```powershell

Â  Â dotnet list package | findstr Coelsa.Artifact.Secrets

```

2. Agrega el using correcto:

```csharp

Â  Â using Coelsa.Artifact.Secrets;

```

3. Restaura los paquetes:

```powershell

Â  Â dotnet restore

```
---

  
## ğŸ“š Recursos Adicionales


### DocumentaciÃ³n

  

- **DocumentaciÃ³n Oficial Coelsa**: [SharePoint - Arquitectura](https://coelsa.sharepoint.com/:f:/s/CTO/Es8icxgXiPxLuQ9nC0Q9bocBAZpK0mKyDNCPyfSh7QlN7Q?e=obdL8c)

- **Repositorio del Proyecto**: [Azure DevOps](https://dev.azure.com/coelsa/Arquitectura/_git/ng-net-secrets)

- **Azure Key Vault**: [Microsoft Docs](https://docs.microsoft.com/azure/key-vault/)
  

### Paquetes NuGet Relacionados

  

- [Azure.Extensions.AspNetCore.Configuration.Secrets](https://www.nuget.org/packages/Azure.Extensions.AspNetCore.Configuration.Secrets/) - v1.4.0

- [Azure.Identity](https://www.nuget.org/packages/Azure.Identity/) - v1.13.2

- [Azure.Security.KeyVault.Secrets](https://www.nuget.org/packages/Azure.Security.KeyVault.Secrets/) - v4.7.0

  

### Ejemplos Completos

  

Consulta el proyecto de ejemplo incluido en el repositorio:

  

```

ng-net-secrets/

â”œâ”€â”€ example/

â”‚ Â  â””â”€â”€ ServiceApi/

â”‚ Â  Â  Â  â”œâ”€â”€ Program.cs

â”‚ Â  Â  Â  â”œâ”€â”€ Configuration/

â”‚ Â  Â  Â  â”‚ Â  â””â”€â”€ SecretsSettings.cs

â”‚ Â  Â  Â  â””â”€â”€ Controllers/

â”‚ Â  Â  Â  Â  Â  â””â”€â”€ ValuesController.cs

```

  

### Soporte

  

Para reportar problemas o solicitar funcionalidades:

  

1. **Issues**: [Azure DevOps - Work Items](https://dev.azure.com/coelsa/Arquitectura/_workitems)

2. **Email**: arquitectura@coelsa.com

3. **Teams**: Canal de Arquitectura

  

---
  

## ğŸ‘¥ Equipo y Contribuciones

  

**Desarrollado por:** Equipo de Arquitectura Â 

**Empresa:** Compensadora ElectrÃ³nica S.A. (Coelsa) Â 

**Copyright:** Â© 2025 Coelsa - Todos los derechos reservados

  

### Contribuidores

  

Para contribuir al proyecto, consulta las guÃ­as de contribuciÃ³n en el repositorio o contacta al equipo de arquitectura.

  

---

  

## ğŸ“Š Versionamiento

  

Este proyecto sigue [Semantic Versioning](https://semver.org/):

  

- **MAJOR**: Corresponde a la versiÃ³n de .Net utilizada

- **MINOR**: Nuevas funcionalidades o modificaciones incompatibles con versiones anteriores

- **PATCH**: Nuevas funcionalidades o correcciones de errores compatibles

  

**VersiÃ³n Actual:** `8.0.0-RC`
**VersiÃ³n Actual:** `8.0.0`

---

  

Â¿Preguntas? Contacta al equipo de arquitectura en arquitectura@coelsa.com