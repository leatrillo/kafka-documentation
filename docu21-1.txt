<div style="background-color: rgba(0, 0, 0, 0.8); border-radius: 60px">

![Banner](/.attachments/banner-d8ceca44-805f-4dd2-b8dc-8d1d3905810d.png =385x120)

</div>  
   

# Coelsa.Artifact.Kafka

[![.NET Version](https://img.shields.io/badge/.NET-10.0-blue)](https://dotnet.microsoft.com/download/dotnet/10.0)
[![NuGet Version](https://img.shields.io/badge/NuGet-10.0.0--RC-brightgreen)](https://www.nuget.org/)

Paquete NuGet para implementar mensajer√≠a con Apache Kafka en aplicaciones .NET 10 utilizando Confluent.Kafka. Este paquete proporciona una soluci√≥n integral para **producci√≥n**, **consumo** de mensajes y **patr√≥n Outbox** con soporte transaccional.

## üìã Tabla de Contenidos

- [Caracter√≠sticas](#-caracter√≠sticas)
- [Arquitectura](#-arquitectura)
- [Requisitos](#-requisitos)
- [Instalaci√≥n](#-instalaci√≥n)
- [Configuraci√≥n](#-configuraci√≥n)
  - [Configuraci√≥n de Producer](#configuraci√≥n-de-producer)
  - [Configuraci√≥n de Consumer](#configuraci√≥n-de-consumer)
  - [Configuraci√≥n de Outbox](#configuraci√≥n-de-outbox)
  - [Configuraci√≥n en Program.cs](#configuraci√≥n-en-programcs)
- [Uso](#-uso)
  - [Producer (Productor)](#1-producer-productor)
  - [Consumer (Consumidor)](#2-consumer-consumidor)
  - [Patr√≥n Outbox](#3-patr√≥n-outbox)
- [Ejemplos Avanzados](#-ejemplos-avanzados)
- [Seguridad](#-seguridad)
- [Troubleshooting](#-troubleshooting)
- [Documentaci√≥n Adicional](#-documentaci√≥n-adicional)

## üöÄ Caracter√≠sticas

- ‚úÖ **Producer (Queue y Event)**: Env√≠o de mensajes transaccionales y no transaccionales
- ‚úÖ **Consumer**: Consumo de mensajes con procesamiento as√≠ncrono
- ‚úÖ **Patr√≥n Outbox**: Garant√≠a de entrega con persistencia en SQL Server
- ‚úÖ **Mensajes CloudEvents**: Formato estandarizado seg√∫n especificaci√≥n CloudEvents
- ‚úÖ **Soporte transaccional**: Transacciones de Kafka para garantizar entrega
- ‚úÖ **Background Services**: Procesamiento autom√°tico de mensajes en segundo plano
- ‚úÖ **Alta disponibilidad**: Manejo de reintentos y mensajes hu√©rfanos
- ‚úÖ **Configuraci√≥n flexible**: M√∫ltiples opciones de configuraci√≥n seg√∫n necesidades
- ‚úÖ **Compatible con .NET 10**: Aprovecha las √∫ltimas caracter√≠sticas del framework

## üèóÔ∏è Arquitectura
flowchart LR App["Aplicaci√≥n\n(.NET 10)"] Producer["Kafka Producer"] Consumer["Kafka Consumer"] Outbox["Outbox Pattern\n(SQL Server)"] Kafka["Apache Kafka\nCluster"]

subgraph Producci√≥n
    App -->|"Env√≠o directo"| Producer
    App -->|"Env√≠o con Outbox"| Outbox
    Outbox -->|"Background Service"| Producer
    Producer -->|"Publicar mensajes"| Kafka
end

subgraph Consumo
    Kafka -->|"Leer mensajes"| Consumer
    Consumer -->|"Procesar"| App
end

classDef app fill:#d9edf7,stroke:#31708f,color:#31708f
classDef infra fill:#dff0d8,stroke:#3c763d,color:#3c763d
classDef pattern fill:#fcf8e3,stroke:#8a6d3b,color:#8a6d3b

class App app
class Producer,Consumer,Kafka infra
class Outbox pattern


### Componentes Principales

1. **Producer**: Env√≠a mensajes a Kafka (Queue Producer y Event Producer)
2. **Consumer**: Consume mensajes de t√≥picos de Kafka
3. **Outbox Pattern**: Almacena mensajes en SQL Server antes de enviarlos a Kafka
4. **Background Services**: Procesa mensajes del Outbox autom√°ticamente

## üì¶ Requisitos

- [.NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0) o superior
- IDE compatible:
  - [Visual Studio 2022](https://visualstudio.microsoft.com/vs/) (17.12 o superior)
  - [Visual Studio Code](https://code.visualstudio.com/) con extensi√≥n C#
- Apache Kafka cluster accesible
- SQL Server (para patr√≥n Outbox)
- Acceso al repositorio privado de NuGet de Coelsa

## üîß Instalaci√≥n

### 1. Configurar origen de NuGet

Agregue el repositorio privado de Coelsa a sus or√≠genes de NuGet.

**Mediante archivo .csproj:**
<PackageReference Include="Coelsa.Artifact.Kafka" Version="10.0.0-RC" />


## ‚öôÔ∏è Configuraci√≥n

### Configuraci√≥n de Producer

Agregue el siguiente bloque en `appsettings.json`:

{ "KafkaSettings": { "QueueProducer": { "BootstrapServers": "localhost:9092", "EnableIdempotence": true, "EnableTransaction": false, "Acks": "all", "MaxInFlight": 5, "LingerMs": 10, "CompressionType": "snappy", "Security": { "Username": "", "Password": "" } }, "EventProducer": { "BootstrapServers": "localhost:9092", "EnableIdempotence": true, "EnableTransaction": false, "Acks": "all", "MaxInFlight": 5, "LingerMs": 10, "CompressionType": "snappy", "Security": { "Username": "", "Password": "" } } } }


#### Descripci√≥n de Par√°metros de Producer

| Par√°metro | Tipo | Descripci√≥n | Valor por defecto |
|-----------|------|-------------|-------------------|
| `BootstrapServers` | string | Lista de brokers de Kafka | `"localhost:9092"` |
| `EnableIdempotence` | bool | Habilita producci√≥n idempotente | `true` |
| `EnableTransaction` | bool | Habilita transacciones de Kafka | `false` |
| `Acks` | string | Nivel de confirmaci√≥n: `0`, `1`, `all` | `"all"` |
| `MaxInFlight` | int | M√°ximo de requests sin respuesta | `5` |
| `LingerMs` | int | Tiempo de espera para agrupar mensajes (ms) | `10` |
| `CompressionType` | string | Tipo de compresi√≥n: `none`, `gzip`, `snappy`, `lz4`, `zstd` | `"snappy"` |
| `Username` | string | Usuario para autenticaci√≥n SASL | `""` |
| `Password` | string | Contrase√±a para autenticaci√≥n SASL | `""` |

### Configuraci√≥n de Consumer

{ "KafkaSettings": { "Consumer": { "BootstrapServers": "localhost:9092", "GroupId": "my-consumer-group", "AutoOffsetReset": "earliest", "EnableAutoCommit": false, "Security": { "Username": "", "Password": "" } } } }


#### Descripci√≥n de Par√°metros de Consumer

| Par√°metro | Tipo | Descripci√≥n | Valor por defecto |
|-----------|------|-------------|-------------------|
| `BootstrapServers` | string | Lista de brokers de Kafka | `"localhost:9092"` |
| `GroupId` | string | Identificador del grupo de consumidores | `""` |
| `AutoOffsetReset` | string | Comportamiento inicial: `earliest`, `latest`, `none` | `"earliest"` |
| `EnableAutoCommit` | bool | Habilita commit autom√°tico de offsets | `false` |
| `Username` | string | Usuario para autenticaci√≥n SASL | `""` |
| `Password` | string | Contrase√±a para autenticaci√≥n SASL | `""` |

### Configuraci√≥n de Outbox

{ "OutboxOptions": { "BatchSize": 100, "OrphanCleanupEnabled": true, "OrphanageTimeout": "00:05:00", "MaxConcurrency": 10, "OrphanCleanupProbability": 0.1, "SqlServer": { "ConnectionString": "Server=localhost;Database=MyDb;Trusted_Connection=True;", "Initials": "APP", "OrphanageTimeout": "00:05:00", "BatchSizeDeleteProcessed": 1000, "CommandTimeoutSeconds": 300 } } }


#### Descripci√≥n de Par√°metros de Outbox

| Par√°metro | Descripci√≥n | Valor por defecto |
|-----------|-------------|-------------------|
| `BatchSize` | Cantidad de mensajes a procesar por lote | `100` |
| `OrphanCleanupEnabled` | Habilita limpieza de mensajes hu√©rfanos | `true` |
| `OrphanageTimeout` | Tiempo para considerar un mensaje hu√©rfano | `"00:05:00"` |
| `MaxConcurrency` | Nivel de concurrencia para procesamiento | `10` |
| `OrphanCleanupProbability` | Probabilidad de ejecutar limpieza (0.0 - 1.0) | `0.1` |
| `Initials` | Prefijo para tablas de base de datos | `""` |
| `BatchSizeDeleteProcessed` | Cantidad de mensajes procesados a eliminar | `1000` |
| `CommandTimeoutSeconds` | Timeout para comandos SQL | `300` |

### Configuraci√≥n en Program.cs

#### Para Producer

using Coelsa.Artifact.Kafka;
var builder = WebApplication.CreateBuilder(args);
// Registrar producer (Queue y Event) builder.Services.AddCoelsaProducerKafka(builder.Configuration);
var app = builder.Build(); app.Run();


#### Para Consumer

using Coelsa.Artifact.Kafka;
var builder = WebApplication.CreateBuilder(args);
// Registrar consumer builder.Services.AddCoelsaConsumerKafka(builder.Configuration);
var app = builder.Build(); app.Run();


#### Para Outbox Service

using Coelsa.Artifact.Kafka.Outbox;
var builder = WebApplication.CreateBuilder(args);
// Registrar Outbox Service con Background Service builder.Services.AddCoelsaOutboxService( builder.Configuration, builder.Environment.EnvironmentName );
// O solo para producir mensajes con Outbox builder.Services.AddCoelsaOutboxProducer(builder.Configuration);
var app = builder.Build(); app.Run();


## üìò Uso

### 1. Producer (Productor)

#### Env√≠o B√°sico con Queue Producer

using Coelsa.Artifact.Kafka.Handler.Interfaces; using Coelsa.Artifact.Kafka.Model;
[ApiController] [Route("api/[controller]")] public class OrdersController : ControllerBase { private readonly ICoelsaKafkaProducer _producer;

public OrdersController(ICoelsaKafkaProducer producer)
{
    _producer = producer;
}

[HttpPost]
public async Task<IActionResult> CreateOrder([FromBody] Order order)
{
    // Crear el mensaje CloudEvents
    var message = new CoelsaMessage<Order>(
        data: order,
        type: "order.created",
        source: "urn:coelsa.com.ar/orders/service"
    )
    {
        Id = Guid.NewGuid().ToString()
    };

    // Configurar el t√≥pico
    var config = new MessageConfiguration(
        topic: "orders-topic",
        producerType: "queue_producer"
    );

    // Publicar mensaje
    await _producer.PublishMessageJsonFormatAsync(config, message);

    return Ok(new { message = "Orden creada exitosamente" });
}
}


#### Env√≠o con Key (Particionamiento)

[HttpPost("with-key")] public async Task<IActionResult> CreateOrderWithKey( [FromBody] Order order, [FromQuery] int? customerId) { var message = new CoelsaMessage<Order>(order, "order.created", "urn:coelsa.com.ar/orders") { // Si customerId es null, se genera un Guid; sino se usa el customerId Id = customerId?.ToString() ?? Guid.NewGuid().ToString() };
var config = new MessageConfiguration("orders-topic", "queue_producer");

await _producer.PublishMessageJsonFormatAsync(config, message);

return Ok(); }


#### Env√≠o en Lote

[HttpPost("batch")] public async Task<IActionResult> CreateOrdersBatch([FromBody] List<Order> orders) { foreach (var order in orders) { var message = new CoelsaMessage<Order>( order, "order.created", "urn:coelsa.com.ar/orders" ) { Id = Guid.NewGuid().ToString() };
 var config = new MessageConfiguration("orders-topic", "queue_producer");

    await _producer.PublishMessageJsonFormatAsync(config, message);
}

return Ok(new { message = $"Se enviaron {orders.Count} √≥rdenes" }); }


### 2. Consumer (Consumidor)

#### Crear un Background Service Consumer

using Confluent.Kafka; using Coelsa.Artifact.Kafka.Handler.Interfaces; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging;
public class OrderConsumerBackgroundService : BackgroundService { private readonly ILogger<OrderConsumerBackgroundService> _logger; private readonly ICoelsaKafkaConsumer _consumerProvider; private readonly IConsumer<string, string> _consumer;
public OrderConsumerBackgroundService(
    ILogger<OrderConsumerBackgroundService> logger,
    ICoelsaKafkaConsumer consumerProvider)
{
    _logger = logger;
    _consumerProvider = consumerProvider;

    var config = new ConsumerConfig
    {
        BootstrapServers = "localhost:9092",
        GroupId = "order-processor-group",
        AutoOffsetReset = AutoOffsetReset.Earliest,
        EnableAutoCommit = false
    };

    _consumer = new ConsumerBuilder<string, string>(config).Build();
    _consumer.Subscribe("orders-topic");
}

protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    _logger.LogInformation("Order Consumer iniciado");

    while (!stoppingToken.IsCancellationRequested)
    {
        try
        {
            await _consumerProvider.ConsumeAsync<Order>(
                _consumer, 
                async (order, ct) =>
                {
                    _logger.LogInformation(
                        "Procesando orden: {OrderId}, Cliente: {CustomerId}, Monto: {Amount}",
                        order?.Id, 
                        order?.CustomerId, 
                        order?.TotalAmount
                    );

                    // Procesar la orden
                    await Task.Delay(100, ct); // Simular procesamiento

                    return true; // Confirmar procesamiento exitoso
                }, 
                stoppingToken
            );
        }
        catch (OperationCanceledException)
        {
            _logger.LogInformation("Consumer detenido");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error al consumir mensaje");
            await Task.Delay(1000, stoppingToken);
        }
    }
}

public override void Dispose()
{
    _consumer.Close();
    _consumer.Dispose();
    base.Dispose();
}}


#### Registrar el Background Service
// En Program.cs builder.Services.AddHostedService<OrderConsumerBackgroundService>();


#### Consumer con Manejo de Errores

protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { try { bool processed = await _consumerProvider.ConsumeAsync<Order>( _consumer, async (order, ct) => { try { await ProcessOrderAsync(order, ct); return true; // Commit del offset } catch (ValidationException ex) { _logger.LogWarning(ex, "Orden inv√°lida, se descarta"); return true; // Commit para no reprocesar } catch (Exception ex) { _logger.LogError(ex, "Error procesando orden"); return false; // No commit, se reintentar√° } }, stoppingToken );
  if (!processed)
        {
            await Task.Delay(5000, stoppingToken); // Esperar antes de reintentar
        }
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error cr√≠tico en consumer");
        await Task.Delay(10000, stoppingToken);
    }
} }



### 3. Patr√≥n Outbox

El patr√≥n Outbox garantiza la entrega de mensajes almacen√°ndolos primero en SQL Server y luego proces√°ndolos en background.

#### Configurar Outbox Producer

using Coelsa.Artifact.Kafka.Outbox.Services.Interfaces;
[ApiController] [Route("api/[controller]")] public class PaymentsController : ControllerBase { private readonly IOutboxService _outboxService;
public PaymentsController(IOutboxService outboxService)
{
    _outboxService = outboxService;
}

[HttpPost]
public async Task<IActionResult> ProcessPayment([FromBody] Payment payment)
{
    // Crear mensaje
    var message = new CoelsaMessage<Payment>(
        payment, 
        "payment.processed", 
        "urn:coelsa.com.ar/payments"
    )
    {
        Id = Guid.NewGuid().ToString()
    };

    // Guardar en Outbox (se enviar√° autom√°ticamente)
    await _outboxService.PublishQueueMessageAsync(
        topic: "payments-topic",
        message: message
    );

    return Ok(new { message = "Pago procesado, mensaje en cola" });
}
}


#### Script SQL para Crear Tabla Outbox

CREATE TABLE [dbo].[APP_OUTBOX_MESSAGES] ( [OMSG_ID] UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(), [OMSG_KEY] NVARCHAR(450) NOT NULL, [OMSG_PRODUCER_TYPE] INT NOT NULL, [OMSG_TOPIC] NVARCHAR(255) NOT NULL, [OMSG_PAYLOAD] NVARCHAR(MAX) NOT NULL, [OMSG_SPEC_VERSION] NVARCHAR(50) NOT NULL, [OMSG_SOURCE] NVARCHAR(500) NOT NULL, [OMSG_TYPE] NVARCHAR(255) NOT NULL, [OMSG_TIME] DATETIME2 NOT NULL, [OMSG_DATA_CONTENT_TYPE] NVARCHAR(100) NOT NULL, [OMSG_TRACE_ID] NVARCHAR(100), [OMSG_STATUS] INT NOT NULL DEFAULT 0, [OMSG_CREATED_AT] DATETIME2 NOT NULL DEFAULT GETUTCDATE(), [OMSG_PROCESSED_AT] DATETIME2 NULL, [OMSG_ERROR] NVARCHAR(4000) NULL, [OMSG_RETRY_COUNT] INT NOT NULL DEFAULT 0, [OSMG_NEXT_RETRY_AT] DATETIME2 NULL, [OSMG_VERSION] INT NOT NULL DEFAULT 1, [OMSG_PROCESSING_INSTANCE_ID] NVARCHAR(100) NULL, [OMSG_PROCESSING_STARTED_AT] DATETIME2 NULL, [OMSG_PROCESSING_EXPIRES_AT] DATETIME2 NULL, [OMSG_INSTANCE_ID] UNIQUEIDENTIFIER NULL, [OMSG_CLAIMED_AT] DATETIME2 NULL );
CREATE INDEX IX_OUTBOX_STATUS_CLAIMED ON [dbo].[APP_OUTBOX_MESSAGES]([OMSG_STATUS], [OMSG_CLAIMED_AT]);



## üí° Ejemplos Avanzados

### Ejemplo Completo: API con Producer y Consumer

**Modelos:**

public class Invoice { public string Id { get; set; } = string.Empty; public int CustomerId { get; set; } public decimal TotalAmount { get; set; } public string Currency { get; set; } = "USD"; }


**Producer Endpoint:**

app.MapPost("/kafka-producer/{amount}/{key?}", async ( [FromRoute] int amount, [FromRoute] int? key, [FromServices] ICoelsaKafkaProducer producer) => { if (amount < 1) amount = 1;
for (int i = 0; i < amount; i++)
{
    var invoice = new Invoice
    {
        Id = Guid.NewGuid().ToString(),
        CustomerId = i + 1,
        TotalAmount = new Random().Next(100, 10000),
        Currency = i % 2 == 0 ? "USD" : "ARS"
    };

    var message = new CoelsaMessage<Invoice>(
        invoice, 
        "invoice.created", 
        "urn:coelsa.com.ar/billing/invoice"
    )
    {
        Id = key?.ToString() ?? Guid.NewGuid().ToString()
    };

    var config = new MessageConfiguration(
        "dev_arq_stream_updated", 
        "queue_producer"
    );

    await producer.PublishMessageJsonFormatAsync(config, message);
}

return Results.Ok($"Se enviaron {amount} mensajes");
}) .WithOpenApi();


## üîí Seguridad

### Autenticaci√≥n SASL

{ "KafkaSettings": { "QueueProducer": { "BootstrapServers": "kafka.coelsa.com.ar:9093", "Security": { "Username": "kafka-user", "Password": "secure-password" } } } }


### Mejores Pr√°cticas

1. **Nunca hardcodear credenciales** en el c√≥digo
2. **Usar Azure Key Vault** para almacenar secretos
3. **Habilitar SSL/TLS** en producci√≥n
4. **Rotar credenciales** peri√≥dicamente
5. **Limitar permisos** por principio de menor privilegio

## üîç Troubleshooting

### Problema: Los mensajes no se env√≠an

**Soluci√≥n:** Verificar conectividad y configuraci√≥n

try { await _producer.PublishMessageJsonFormatAsync(config, message); } catch (ProduceException<string, string> ex) { _logger.LogError(ex, "Error produciendo mensaje: {Reason}", ex.Error.Reason); }


### Problema: Consumer no procesa mensajes

**Verificar:**
- El `GroupId` sea √∫nico y correcto
- El t√≥pico exista y tenga mensajes
- La configuraci√≥n de `AutoOffsetReset`

### Problema: Outbox acumula mensajes

**Soluci√≥n:** Verificar el Background Service

// Revisar logs del servicio _logger.LogInformation("Procesados {Count} mensajes del Outbox", count);


## üìö Documentaci√≥n Adicional

- [Repositorio del proyecto](https://dev.azure.com/coelsa/Arquitectura/_git/ng-net-Kafka)
- [Apache Kafka Documentation](https://kafka.apache.org/documentation/)
- [Confluent.Kafka .NET](https://docs.confluent.io/kafka-clients/dotnet/current/overview.html)
- [CloudEvents Specification](https://cloudevents.io/)

## üë• Autores

Equipo de Arquitectura - Coelsa

## üìû Soporte

Para soporte t√©cnico y consultas, contactar al equipo de arquitectura a trav√©s de los canales internos de Coelsa.

---

**Versi√≥n del paquete**: 10.0.0-RC  
**√öltima actualizaci√≥n**: 2026